# descriptions.py
descriptions = {
    "thread": {
        1: {
            1: "در این سناریو، ده نخ به ترتیب ایجاد و اجرا می‌شوند. هر نخ تابع my_func را با شماره‌ای خاص اجرا کرده و بلافاصله منتظر می‌ماند تا اجرای آن پایان یابد. اجرای ترتیبی باعث می‌شود همه خروجی‌ها به ترتیب دیده شوند.",
            2: "در این سناریو نخ‌ها در سه گروه (۱و۲، سپس ۵و۶و۷، سپس ۳و۴و بقیه) به ترتیب اجرا و تکمیل می‌شوند، با تأخیر تصادفی در هر گروه.",
            3: "در این سناریو به هر نخ تأخیر تصادفی داده شده، که باعث می‌شود ترتیب اجرای نخ‌ها به هم بریزد و خروجی‌ها غیر قابل پیش‌بینی باشند. این شبیه‌سازی خوبی برای محیط‌های رقابتی است.",
        },
        2: {
            1: "در این سناریو سه تابع A، B و C با نخ جداگانه اجرا می‌شوند. اما به علت استفاده از join بلافاصله بعد از start، اجرای آن‌ها به صورت ترتیبی و منظم خواهد بود.",
            2: "در این سناریو نیز همان سه تابع اجرا می‌شوند، ولی بدون join بلافاصله پس از start. به همین دلیل اجراها هم‌زمان و موازی خواهند بود.ولی چون تأخیرها یکسانن، خروجی‌ها معمولاً منظم و نزدیک به همند.",
            3: "مشابه سناریوی قبلی است ولی این بار تأخیر تصادفی داریم، که باعث ترتیب متفاوت شروع و پایان توابع خواهد شد. خروجی کاملاً غیرقابل‌پیش‌ بینی هست و ترتیب خروجی‌ها به دلیل تأخیرهای تصادفی به هم می‌ریزد.",
        },
        3: {
            1: "نخ‌ها به صورت کلاس تعریف شده‌اند. هر نخ عدد خاصی دارد و پس از اجرا، زمان اجرا و شناسه پردازش را چاپ می‌کند.اجرای ترتیبی رو نشون می‌ده با خروجی منظم و قابل‌پیش‌بینی هست.",
            2: "بر خلاف سناریوی اول، این بار تمام نخ‌ها ابتدا start شده و بعداً join می‌شوند؛ یعنی اجرا هم‌زمان و موازی خواهد بود بنابراین اجرای موازی رو با ترتیب تصادفی نشون می‌ده، چون تأخیرها تصادفی هستند.",
            3: "نخ‌های با شماره زوج با تأخیر اجرا می‌شوند. این باعث تفاوت در ترتیب اجرای خروجی‌ها می‌شود و ساختار واقعی‌تری از برنامه‌ریزی نخ‌ها را نشان می‌دهد.بنابراین اجرای موازی رو با رفتار متفاوت بین نخ‌های زوج و فرد نشان می‌دهد",
        },
        4: {
            1: "در این سناریو از قفل (Lock) استفاده می‌شود تا فقط یک نخ در یک زمان خاص به بخش حساس دسترسی داشته باشد. این از هم‌پوشانی جلوگیری می‌کند.اجرای کاملاً ترتیبی رو نشون می‌ده، با خروجی منظم ولی با ترتیب تصادفی نخ‌ها.",
            2: "این سناریو بدون قفل اجرا می‌شود، بنابراین احتمال هم‌پوشانی بین نخ‌ها وجود دارد.اجرای کاملاً موازی رو با خروجی‌های درهم و سریع نشون می‌ده.",
            3: "اینجا فقط بخش ابتدایی (چاپ پیام شروع) توسط قفل محافظت شده،ترکیبی از اجرای ترتیبی (برای running به دلیل قفل) و موازی (برای over بدون قفل) رو نشون می‌ده، که باعث می‌شه پیام‌های running منظم و پیام‌های over درهم باشن.",
        },
        5: {
            1: "نخ‌ها با استفاده از RLock از داده اشتراکی محافظت می‌کنند. در این سناریو یک سطح قفل داریم و عملیات افزودن و حذف انجام می‌شود.یه قفل ساده کل عملیات رو ترتیبی می‌کند.",
            2: "اینجا قفل به صورت تودرتو گرفته می‌شود (nested lock). نخ می‌تواند چند بار قفل را بدون بن‌بست بگیرد.نشان‌ دهنده قابلیت RLock برای اجازه دادن به نخ برای گرفتن دوباره قفل است.",
            3: "در این سناریو نیز از RLock استفاده می‌شود ولی توابع add و remove به صورت داخلی و تو در تو صدا زده می‌شوند. این یک ساختار پیچیده تر هست که توابع داخلی جداگانه برای ADD و REMOVE داریم که هر کدام قفل خودشون رو دارند، به علاوه یه قفل خارجی.",
        },
        6: {
            1: "دو نخ تولیدکننده، دو آیتم تولید می‌کنند و سپس دو نخ مصرف‌کننده با استفاده از Semaphore آن‌ها را مصرف می‌کنند. ترتیب اجرا با تأخیرها هماهنگ شده است. تولید و مصرف دو آیتم منحصربه‌فرد (۱۰۱ و ۲۰۲) رو با تأخیر زیاد مصرف‌کننده‌ها نشان میدهد.",
            2: "چند نخ تولیدکننده آیتم تولید می‌کنند و یک نخ مصرف‌کننده همه آن‌ها را مصرف می‌کند. سینک‌ شدن با استفاده از semaphore انجام می‌شود.(تولید و مصرف ترتیبی ۵ آیتم (۱ تا ۵) رو با یه مصرف‌کننده در حلقه نشون می‌ده، با خروجی طولانی‌تر و منظم.)",
            3: "اول نخ‌های مصرف‌کننده شروع می‌شوند و منتظر می‌مانند تا تولیدکننده‌ها آیتم تولید کنند. سپس ادامه می‌دهند.(تولید و مصرف دو آیتم یکسان (۹۹۹) رو با شروع زودهنگام مصرف‌کننده‌ها نشون می‌ده، با خروجی کوتاه‌تر و ساده‌تر.)",
        },
        7: {
            1: "در این سناریو، سه نخ با Barrier سینک می‌شوند. زمانی که هر سه به مانع برسند، همه همزمان ادامه می‌دهند.(یک مسابقه ساده با خروجی کوتاه و همزمان را نشان می‌دهد.همه نخ‌ها همزمان به پایان می‌رسند.)",
            2: "مانند سناریوی ۱ است ولی یک نخ (Louie) با تأخیر به مانع می‌رسد که باعث انتظار دیگر نخ‌ها و تأخیر کلی می‌شود(تأخیر Louie باعث می‌شه پیامش دیرتر چاپ بشه).",
            3: "دو مرحله از Barrier داریم که نخ‌ها باید در هر دو مرحله با هم سینک شوند. شبیه‌سازی مسابقه چندمرحله‌ای است.(یک مسابقه دو مرحله‌ای با خروجی پیچیده‌تر، پیام‌های اضافی و ترتیب تصادفی در هر مرحله، ولی با همگام‌سازی کامل در پایان هر مرحله.)",
        },
    },
    "process": {
        1: {
            1: "در این سناریو یک فرایند جدید ایجاد شده و فقط یک پیام از آن چاپ می‌شود. سپس ID فرایند اصلی چاپ می‌شود.(ساده‌ترین حالت با یه فرایند و خروجی ترتیبی را نشون می‌دهد.اجرا کاملاً ترتیبی، چون فقط یه فرایند وجود دارد.)",
            2: "در این سناریو چند فرایند ایجاد شده و به صورت هم‌زمان اجرا می‌شوند. هر کدام شماره خود را چاپ می‌کنند.(درهم و موازی، چون ۵ فرایند همزمان اجرا می‌شن و پیام‌ها ممکنه مخلوط بشن.اجرای موازی ۵ فرایند با خروجی‌های درهم و تعداد پیام‌های متغیر رو نمایش می‌ده.)",
            3: "در این سناریو روی چند عدد عملیات مربع انجام شده و خروجی هر کدام چاپ می‌شود. عملیات محاسباتی به فرایندهای جدا واگذار شده.(موازی، ولی به دلیل سادگی محاسبات، پیام‌ها معمولاً منظم‌ترن.محاسبات ساده (مربع اعداد) رو با اجرای موازی و خروجی نسبتاً منظم نشون می‌ده.)",
        },
        2: {
            1: "یک فرایند با نام سفارشی اجرا می‌شود و نامش هنگام اجرا چاپ می‌شود.(فقط پیام شروع با نام سفارشی.)",
            2: "چند فرایند با نام‌های متفاوت (Worker-1 و غیره) اجرا می‌شوند و پیام شروع و پایان هرکدام چاپ می‌شود.(اجرای موازی ۳ فرایند با نام‌های سفارشی و پیام‌های شروع/پایان رو نمایش می‌ده، با خروجی‌های درهم به دلیل تأخیر.)",
            3: "نام‌گذاری فرایندها در زمان ایجاد در والد چاپ می‌شود و سپس هر فرایند هنگام اجرا، نام خودش را اعلام می‌کند.(پیام‌های running با نام‌های NamedProcess-X و پیام‌های Created از والد.دسترسی به نام فرایندها از والد رو نشون می‌ده، با اجرای موازی و پیام‌های ساده running.)",
        },
        3: {
            1: "یک فرایند در پس‌زمینه اجرا می‌شود ولی بدون join. یعنی فرایند اصلی منتظر نمی‌ماند.(فرایند پس‌زمینه (فرایند فرزند) بدون join رو نشون می‌ده که مستقل ادامه می‌ده. اجرای موازی و درهم، پیام‌های MainProcess و Process-1 مخلوط می‌شن، فرایند فرزند ادامه می‌ده.)",
            2: "فرایند با خاصیت daemon اجرا می‌شود و با اتمام فرایند اصلی، خودبه‌خود متوقف می‌شود.(فرایند daemon رو نمایش می‌ده که با پایان فرایند اصلی متوقف می‌شه.اجرای موازی، اما پیام‌های daemon ناقص می‌مونن (به دلیل توقف با MainProcess).)",
            3: "مقایسه تفاوت بین join و بدون join. یکی از فرایندها اجرا شده و صبر می‌کنیم، دیگری هم‌زمان ادامه دارد.(join (WithJoin منتظر می‌مونه) و بدون join (NoJoin ادامه می‌ده. اجرا موازی و درهم، NoJoin ممکنه بعد از پایان MainProcess پیام چاپ کنه.))",
        },
        4: {
            1: "فرایندی بی‌نهایت اجرا می‌شود و بعد از چند ثانیه از طرف فرایند اصلی متوقف می‌شود.خاتمه اجباری (terminate) یه فرایند با حلقه رو نشون می‌ده که خروجی ناقص تولید می‌کنه.(پیام‌ها درهم و موازی) ",
            2: "فرایند طولانی اجرا می‌شود و اگر بیش از حد طول بکشد، توسط فرایند اصلی terminate می‌شود. این خاتمه طبیعی یه فرایند رو نمایش می‌ده چون فرایند خودش متوقف می‌شه(پیام‌ها ترتیبی‌تر، چون فرایند فرزند خودش متوقف می‌شه و terminate اجرا نمی‌شه.).",
            3: "چند فرایند طولانی ایجاد می‌شوند و بعد از مدتی همه آن‌ها توسط والد کشته می‌شوند. اینجا خاتمه اجباری چند فرایند رو نشون می‌ده(خاتمه اجباری همه فرایندها) با خروجی ساده‌تر و پیام‌های وضعیت برای هر فرایند.(پیام‌های شروع فرایندها موازی و درهم، سپس پیام‌های خاتمه MainProcess ترتیبی.)",
        },
        5: {
            1: "فرایند به صورت کلاس تعریف شده و فقط پیامی چاپ می‌کند.این ساده‌ترین فرایند مبتنی بر کلاس با خروجی کوتاه و ترتیبی رو نشون می‌ده.(اجرا کاملاً ترتیبی، چون یه فرایند بدون تأخیر.)",
            2: "فرایندها به صورت کلاس با ورودی عدد ایجاد می‌شوند. هر کدام شناسه و پایان خود را اعلام می‌کنند. اجرای موازی ۱۰ فرایند با پیام‌های شروع و پایان و خروجی درهم رو نمایش می‌ده.(اجرا موازی و درهم، پیام‌های شروع و پایان فرایندها ممکنه مخلوط بشن.)",
            3: "کلاسی از فرایند داریم که شمارش بین دو عدد را انجام می‌دهد و آن‌ها را چاپ می‌کند. این یه فرایند با منطق شمارش و خروجی ترتیبی با پیام‌های متعدد رو نشون می‌ده.(پیام‌های شمارش از ۱ تا ۱۰ با منطق مشخص. بنابراین اجرا ترتیبی هست ، چون یه فرایند داریم با منطق شمارش.)",
        },
        6: {
            1: "یک صف ساده استفاده می‌شود تا یک پیام بین فرایند فرزند و والد منتقل شود.ارتباط ساده یک‌طرفه با یه پیام رو نشون می‌ده. (اجرا ترتیبی، چون یه فرایند و یه پیام.)",
            2: "فرایند تولیدکننده چند پیام را به صف می‌فرستد و مصرف‌کننده آن‌ها را می‌خواند.این تبادل چند پیام موازی با تولید و مصرف همزمان رو نمایش می‌ده. (ارتباط یک‌طرفه، چند پیام با اندازه صف. اجرای موازی و درهم، پیام‌های تولید و مصرف مخلوط می‌شن.)",
            3: "دو صف برای ارتباط دوطرفه (client-server) استفاده می‌شود. پیام ارسال و پاسخ uppercase دریافت می‌شود. ارتباط دوطرفه با دو صف و پاسخ‌های تبدیل‌شده رو نشون می‌ده.(اجرای نسبتاً ترتیبی، با تبادل منظم پیام‌ها بین صف‌ها.)",
        },
        7: {
            1: "قفل برای جلوگیری از نوشتن همزمان چند فرایند روی فایل یا خروجی استفاده می‌شود.همگام‌سازی ترتیبی با Lock رو نشون می‌ده که پیام‌ها به ترتیب از صف خوانده می‌شن. Lock، دسترسی ترتیبی به منبع مشترک. پیکربندی‌ها درهم، پیام‌های نوشتن ترتیبی (به دلیل Lock).",
            2: "از event استفاده می‌شود تا دو فرایند تا زمان set شدن توسط والد منتظر بمانند.هماهنگی با Event رو نمایش می‌ده، با انتظار و ادامه بعد از سیگنال.Event، هماهنگی مبتنی بر سیگنال. پیکربندی‌ها و انتظارها درهم، پیام‌های ادامه بعد از تنظیم Event.",
            3: "سه فرایند با استفاده از Barrier هماهنگ می‌شوند. زمانی که هر سه به مانع برسند، همزمان ادامه می‌دهند.همگام‌سازی گروهی با Barrier رو نشون می‌ده، با پیام‌های همزمان رسیدن و عبور. پیکربندی‌ها درهم، پیام‌های رسیدن و عبور گروهی و تقریباً همزمان.",
        },
        8: {
            1: "با استفاده از Pool.map عملیات مربع روی لیستی از اعداد اجرا می‌شود.استفاده از Pool.map() برای محاسبات ساده و سریع رو نشون می‌ده.(پیام‌های محاسبه درهم، نتایج ترتیبی.)",
            2: "با استفاده از Pool.apply_async چند عملیات غیرهمزمان انجام می‌شود و نتایج بعداً جمع‌آوری می‌شود.پردازش با ضرب و تأخیر تصادفی. استفاده از apply_async با تأخیرهای تصادفی و خروجی درهم رو نمایش می‌ده.(پیام‌های پردازش درهم (به دلیل تأخیر تصادفی)، نتایج ترتیبی.)",
            3: "کارهای تأخیری با pool اجرا می‌شوند. نشان‌دهنده اجرای موازی دو‌به‌دو روی تسک‌های پشت سر هم.وظایف تأخیردار با پیام‌های شروع/پایان و اجرای طولانی‌تر رو نشون می‌ده.(پیام‌های شروع/پایان درهم، ولی جفت‌شده، نتایج ترتیبی.)",
        },
    }
}
